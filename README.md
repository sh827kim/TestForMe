# TestForMe
# 업무용 프로그램 개발 방안

## A 고객사 시스템의 채널 확대 및 사용자 증가에 따라 발생하는 인증 및 세션 관리 문제 해결을 위한 인증 방식 개선 방안

- 추정 내용
  - 기존 방식이 세션쿠키 방식 또는 DB 기반 세션 인증 방식일 것으로 추정. 
  - jwt 토큰과 같이 유지 시간을 좀 증가시킬 수 있고, in-memory 캐싱 방식으로 전환하는 방안을 서술하면 될 것 같단 추측이 듦 

### 키워드

| 분류            | 키워드                               | 참조링크                                                     |
| --------------- | ------------------------------------ | ------------------------------------------------------------ |
| 인증 방식       | OAuth2.0                   | https://blog.naver.com/mds_datasecurity/222182943542<br />https://guide.ncloud-docs.com/docs/b2bpls-oauth2 |
|                 | OpenID Connect             | https://hudi.blog/open-id/                                   |
|                 | SAML                       | https://www.okta.com/kr/blog/2020/09/what-is-saml/           |
|                 | 다단계 인증(MFA)           | https://www.silverfort.com/ko/glossary/multi-factor-authentication-mfa/ |
| 세션 관리       | 세션 타임아웃 관리         | https://life-is-potatoo.tistory.com/56                       |
|                 | 세션 스토리지 (예: Redis)  |                                                              |
|                 | 세션 하이재킹 방지         | https://livelyoneweek.tistory.com/67                         |
| 보안 및 암호화  | JWT                        | https://velog.io/@yena1025/JWT-%ED%86%A0%ED%81%B0%EA%B3%BC-%EB%AC%B4%EC%83%81%ED%83%9C%EC%84%B1Stateless<br />https://velog.io/@strangehoon/%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%98%EB%A9%B4-JWT%EB%A5%BC-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C |
|                 | SSL/TLS 암호화             |                                                              |
|                 | 비밀번호 해싱 (예: bcrypt) |                                                              |
| 사용자 경험(UX) | SSO                        | https://aws.amazon.com/ko/what-is/sso/                       |
| 확장성 및 성능  | API 게이트웨이             | https://wildeveloperetrain.tistory.com/205                   |
| 분산 아키텍처   | 분산 세션 관리             | https://developheo.com/bunsan-seobeo-hwangyeongeseoyi-sesyeon-gwanrireul-wihan-3gaji-bangbeob/ |

### 예상 요건 및 해결 방안

| 기존 문제                   | 문제 사유                                                    | 해결방안                                                     | 해결 방안 제시 사유                                          |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 단일 인증 시스템 사용       | 인증 서버에 부하 집중, 시스템 확장성 부족                    | **분산 인증 시스템 구축** (예: OAuth 2.0, OpenID Connect)    | 인증 서버의 부하를 분산시켜 성능을 향상시키고, 확장성 및 가용성을 높일 수 있음. |
| 세션 기반 인증 관리         | 세션 데이터가 서버에 집중되어 부하 증가, 동시 접속자 수 증가에 따른 성능 저하 | **토큰 기반 인증** (예: JWT)로 전환                          | 서버 부담을 줄이고 클라이언트 측에서 인증을 처리하여 시스템 성능을 향상시킬 수 있음. |
| 정적인 세션 타임아웃 정책   | 사용자 활동 패턴에 따른 유연한 세션 관리 부족, 세션 충돌 문제 발생 가능 | **동적 세션 타임아웃** (예: 사용자 활동 기반 세션 연장) 도입 | 사용자 경험을 개선하고 세션 관리 효율성을 높일 수 있음.      |
| 분산 시스템 아키텍처의 부재 | 단일 서버에 트래픽 집중, 서버 확장성 제한                    | **마이크로서비스 아키텍처**로 전환                           | 시스템의 확장성을 높이고, 트래픽 분산을 통해 성능을 최적화할 수 있음. |
| 고정된 인증 방식 사용       | 보안 수준의 제한, 사용 편의성 문제, 새로운 채널 추가 시 인증 방식 변경 필요 | **다중 인증(MFA) 및 생체 인식 인증** 도입                    | 보안을 강화하고, 사용자 경험을 개선하며, 다양한 채널에 쉽게 적용 가능. |


## A 고객사 비즈니스 유연성과 성능 관점에서 상품을 관리하기 위한 데이터 모델을 새롭게 설계하고 설계 사유 제시

- 추정 내용
  - Monolithic RDB 에 굉장히 묶여있는 데이터 모델일 것으로 추정. 
  - 이론적인 MSA 와 같이 분리된 데이터 모델을 설계하면 될 것 같음

### 키워드

| 분류                | 키워드                                 | 참조링크                                                     |
| ------------------- | --------------------------------------- | ------------------------------------------------------------ |
| 데이터 모델링       | 정규화 vs 비정규화            | https://velog.io/@gwichanlee/DB-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94 |
| 성능 최적화         | 인덱스 설계 및 사용           |                                                              |
|                     | 쿼리 최적화                   |                                                              |
|                     | 데이터 파티셔닝               |                                                              |
|                     | 캐싱 계층                     |                                                              |
| 유연성              | 다차원 데이터 모델링          | https://velog.io/@kero88/%EB%8B%A4%EC%B0%A8%EC%9B%90-%EB%AA%A8%EB%8D%B8%EB%A7%81 |
|                     | API를 통한 데이터 액세스      |                                                              |
| 데이터 관리 및 통합 | 데이터 중복 제거              |                                                              |
|                     | 데이터 무결성 유지            |                                                              |
|                     | ETL(Extract, Transform, Load) |                                                              |
| 보안 및 접근 제어   | RBAC                          | https://hello-backend.tistory.com/175                        |
|                     | ABAC                          | 위와 동일                                                    |
| MSA                 | 서비스별 데이터베이스 분리    |                                                              |



| 기존 문제                      | 문제 사유                                                    | 해결방안                                                | 해결 방안 제시 사유                                          |
| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------- | ------------------------------------------------------------ |
| 정규화된 관계형 데이터베이스   | 데이터 조회 시 다중 조인으로 인한 성능 저하                  | **비정규화 또는 데이터 마트 구축**                      | 자주 조회되는 데이터를 별도로 관리하여 쿼리 성능을 개선하고, 다중 조인을 줄일 수 있음. |
| 단일 테이블에 다수의 컬럼 사용 | 테이블이 비대해져 성능 저하 및 새로운 속성 추가 시 스키마 변경 필요 | **속성 기반 테이블 분할 (예: 속성 그룹별 테이블 구성)** | 속성에 따라 테이블을 분할하여 성능을 최적화하고, 스키마 변경 없이 새로운 속성을 추가할 수 있음. |
| 고정된 스키마 구조             | 새로운 상품 유형이나 속성 추가 시 스키마 변경 필요           | **스키마리스(NoSQL) 데이터베이스 도입** (예: MongoDB)   | 비정형 데이터를 유연하게 관리할 수 있으며, 스키마 변경 없이 다양한 상품 유형을 지원 가능. |
| 비효율적인 인덱스 구조         | 잘못된 인덱스 설계로 인한 삽입 및 업데이트 성능 저하         | **인덱스 최적화** 및 **커버링 인덱스 도입**             | 적절한 인덱스 설계로 데이터 삽입 및 조회 성능을 개선하고, 쿼리의 효율성을 높일 수 있음. |
| 트랜잭션 처리 문제             | 실시간 트랜잭션 처리 부족, 동시성 제어 문제 발생             | **비동기 처리** 및 **이벤트 기반 아키텍처**로 전환      | 트랜잭션 처리를 비동기화하여 성능을 향상시키고, 동시성 제어 문제를 완화할 수 있음. |
| 데이터 중복 문제               | 비정규화로 인한 데이터 일관성 문제 및 중복 데이터 업데이트 시 성능 저하 | **데이터 정규화 및 캐싱 전략 도입**                     | 데이터 일관성을 유지하면서 성능을 개선하기 위해 자주 사용되는 데이터를 캐싱하여 관리할 수 있음. |




## 예약 처리 프로세스와 데이터 모델에서 발생하고 있는 동시성 이슈의 해결 방안 제시

| 분류                         | 키워드                                                   | 참조링크                                                     |
| ---------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 동시성 제어                  | Pessimistic Locking<br />(비관적 락)           | https://sabarada.tistory.com/175<br />https://medium.com/@abhirup.acharya009/managing-concurrent-access-optimistic-locking-vs-pessimistic-locking-0f6a64294db7 |
|                              | Optimistic Locking<br />(낙관적 락)            | 위와 동일                                                    |
|                              | MVCC(Multi-Version Concurrency Control)        | https://mangkyu.tistory.com/53<br />https://velog.io/@onejaejae/DB-MVCC |
|                              | Shared Lock & Exclusive Lock                   | https://velog.io/@haron/DB-Exclusive-lock%EA%B3%BC-Shared-lock%EC%9D%98-%EC%B0%A8%EC%9D%B4 |
| 트랜잭션 관리                | ACID 특성                                      | https://akasai.space/db/about_acid/                          |
|                              | 트랜잭션 격리 수준                             | https://akasai.space/db/about_isolation/<br />https://doooyeon.github.io/2018/09/29/transaction-isolation-level.html |
|                              | 2단계 커밋 프로토콜(2PC)                       | https://velog.io/@jungbumwoo/Two-Phase-commit-%EC%9D%B4%EB%9E%80-2PC |
|                              | 분산 트랜잭션 관리                             |                                                              |
| 데드락 및 레이스 컨디션 해결 | 데드락 탐지 및 해결                            | 하단 별도 표 참조                                            |
|                              | 타임아웃 설정                                  |                                                              |
| 비동기 처리                  | 메시지 큐 시스템                               |                                                              |
|                              | 이벤트 소싱                                    | https://velog.io/@boo105/CQRS-%EC%99%80-Event-Sourcing       |
|                              | CQRS(Command Query Responsibility Segregation) | https://velog.io/@everyhannn/CQRS-Event-Sourcing             |
|                              | 작업 대기열(Job Queue)                         |                                                              |
| 성능 및 최적화               | 캐싱 전략 (Redis, Memcached)                   |                                                              |
|                              | 스케줄러 기반 처리                             |                                                              |
|                              | 데이터 파티셔닝                                |                                                              |
| 분산 처리 및 데이터 관리     | 분산 락 매니저                                 |                                                              |
|                              | 멀티 리전 배포                                 |                                                              |
| MSA                          | 사가 패턴 (Saga Pattern)                       | https://velog.io/@suhongkim98/MSA%EC%99%80-DDD-Saga-Pattern-6 |
|                              | 이벤트 드리븐 아키텍처                         |                                                              |



| 기존 문제                         | 문제 사유                                                    | 해결방안                                                     | 해결 방안 제시 사유                                          |
| --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 단일 트랜잭션 처리 방식           | 동시 처리 시 트랜잭션 충돌 및 잠금으로 인한 대기 시간 증가   | **분산 트랜잭션 관리** 및 **CQRS(Command Query Responsibility Segregation) 도입** | 트랜잭션을 분산시켜 충돌을 줄이고, 읽기와 쓰기 작업을 분리해 성능을 향상시킬 수 있음. |
| 낙관적 잠금 또는 비관적 잠금 사용 | 잠금 충돌 및 교착 상태 발생 가능성                           | **비동기 이벤트 기반 처리** 및 **버전 관리 (Versioning)**    | 충돌을 최소화하고, 비동기 처리를 통해 교착 상태를 방지하며 성능을 개선할 수 있음. |
| 단일 테이블 구조                  | 테이블 잠금 경합으로 성능 저하 및 병목 현상 발생             | **테이블 파티셔닝** 또는 **샤딩(Sharding)**                  | 데이터를 분산 저장하여 병목 현상을 줄이고, 동시성 문제를 완화할 수 있음. |
| 즉시 커밋 방식                    | 동시성 문제로 인한 데이터 일관성 저하 및 중복 예약 발생 가능 | **지연 커밋** 또는 **SAGA 패턴** 도입                        | 트랜잭션을 여러 단계로 나누어 처리하고, 중복 예약을 방지하여 데이터 일관성을 유지할 수 있음. |
| 중앙 집중형 아키텍처              | 동시 요청 시 병목 현상 발생, 트래픽 증가 시 성능 저하        | **마이크로서비스 아키텍처** 및 **로드 밸런싱**               | 시스템을 분산 처리하여 확장성을 높이고, 병목 현상을 줄일 수 있음. |
| 수동으로 관리되는 동시성 제어     | 동시성 문제 발생 시 신속한 대응 어려움, 자동화 부족          | **자동화된 동시성 제어** 도입 (예: 데이터베이스 트랜잭션 격리 수준 조정) | 동시성 제어를 자동화하여 신뢰성을 높이고, 문제 발생 시 신속히 대응 가능. |



**데드락 탐지**

| 기법 분류   | 기법                                                         | 설명                                                         |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 데드락 예방 | 자원 할당 그래프(Resource Allocation Graph)        | 자원과 프로세스의 관계를 그래프로 나타내어 데드락 발생 가능성을 사전에 차단하는 방법. |
|             | 은행원 알고리즘(Banker's Algorithm)                | 자원의 최대 요청량을 사전에 고려해, 시스템을 안전한 상태로 유지할 수 있는 경우에만 자원을 할당. |
| 데드락 회피 | Wait-Die Scheme                                    | 오래된 프로세스가 자원을 기다리도록 하고, 젊은 프로세스는 자원을 요청 시 중단하고 재시도. |
|             | Wound-Wait Scheme                                  | 젊은 프로세스가 자원을 요구할 경우, 오래된 프로세스를 중단시키고 자원을 할당. |
|             | 오래된 자원 요청 프로세스 중단(Aging)              | 프로세스의 우선순위를 점진적으로 높여 자원 획득 기회를 증가시켜 데드락을 피하는 방법. |
| 데드락 탐지 | Wait-for 그래프(Wait-for Graph)                    | 시스템 내의 프로세스와 자원 할당 상황을 그래프로 표현하여 주기적으로 사이클을 탐지해 데드락을 확인. |
|             | 데드락 탐지 알고리즘(Deadlock Detection Algorithm) | 시스템 상태를 주기적으로 체크하며, 프로세스 간의 상호 대기 상태를 분석하여 데드락을 탐지. |
| 데드락 해결 | 프로세스 종료(Process Termination)                 | 데드락 상태에 있는 프로세스를 강제로 종료시켜 자원을 회수하는 방법. |
|             | 자원 선점(Resource Preemption)                     | 자원을 점유하고 있는 프로세스로부터 자원을 회수하여 데드락을 해소하는 방법. |
|             | 롤백(Rollback)                                     | 데드락 상태에 있는 프로세스를 이전 안전 상태로 되돌려 데드락 발생 이전의 상태로 복구. |


